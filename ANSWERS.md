Question: Architecture: If we were to transition this from an in-memory array to a real database (like PostgreSQL or MongoDB), what changes would you make to the EnquiryManager architecture?
ANSWER 1: Currently, the system stores enquiries in a simple in-memory array, and once the application is restarted, all the data is lost. I usually experience this when working with SQLite, but in real-world production, we would use PostgreSQL, MongoDB, or other real databases. To transition well, I would create a file that is responsible for saving, retrieving, and searching enquiries in the database. The goal would be to avoid direct interaction with the array. Also, I would make methods async and add proper error handling for failed database operations.
QUESTION 2: Security: What are some potential security risks in the current createEnquiry implementation?
ANSWER 2: There are several concrete risks in the current createEnquiry implementation:
1. Field injection: Because ...data is spread after the server-controlled fields (id, status, createdAt), a caller can pass status: 'resolved' or id: '1' in the input and silently overwrite those values. The fix is to whitelist only the allowed fields (name, email, message) instead of spreading the entire data object.
2. Prototype pollution: If data contains keys like __proto__ or constructor, spreading it can corrupt the object prototype. Whitelisting allowed fields eliminates this vector entirely.
3. XSS (Cross-Site Scripting): The name and message fields accept arbitrary strings with no sanitization. If these values are later rendered in a browser without escaping, an attacker can inject malicious scripts. Input should be escaped/validated before rendering.
4. Abuse and rate limiting: Without authentication, rate limiting, or CAPTCHA, the endpoint is open to spam and denial-of-service attacks. Adding rate limiting per IP and optionally CAPTCHA or authentication will mitigate this.
